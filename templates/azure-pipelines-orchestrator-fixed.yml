# Azure DevOps Pipeline: EasyPIM Policy Orchestrator
# Equivalent to GitHub workflow: 02-orchestrator-test.yml

trigger: none # Manual trigger only

parameters:
- name: serviceConnection
  displayName: 'Azure Service Connection'
  type: string
  default: 'EasyPIM-Azure-Connection'

- name: keyVaultName
  displayName: 'Key Vault Name'
  type: string
  default: 'default'

- name: run_description
  displayName: 'Custom description for this run (optional)'
  type: string
  default: 'EasyPIM Orchestrator Execution'

- name: configSecretName
  displayName: 'Key Vault secret name containing PIM configuration (optional)'
  type: string
  default: 'default'

- name: WhatIf
  displayName: 'Preview mode - show what would be done without making changes'
  type: boolean
  default: true

- name: Mode
  displayName: 'Orchestrator execution mode'
  type: string
  default: 'delta'
  values:
  - delta
  - initial

variables:
- group: EasyPIM-EventDriven-Governance
- name: KEYVAULT_NAME
  ${{ if ne(parameters.keyVaultName, 'default') }}:
    value: ${{ parameters.keyVaultName }}
  ${{ else }}:
    value: $(AZURE_KEY_VAULT_NAME)
- name: SECRET_NAME
  ${{ if ne(parameters.configSecretName, 'default') }}:
    value: ${{ parameters.configSecretName }}
  ${{ else }}:
    value: $(EASYPIM_SECRET_NAME)
- name: SERVICE_CONNECTION_NAME
  value: ${{ parameters.serviceConnection }}

pool: Default

name: EasyPIM_Orchestrator_$(Date:yyyyMMdd)_$(Rev:r)

stages:
- stage: Validation
  displayName: 'Pre-execution Validation'
  jobs:
  - job: ValidateInputs
    displayName: 'Validate Configuration'
    steps:
    - checkout: self
      displayName: 'Checkout Repository'

    - task: AzureCLI@2
      displayName: 'Validate EasyPIM Configuration'
      inputs:
        azureSubscription: $(SERVICE_CONNECTION_NAME)
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          Write-Host "üîç Validating EasyPIM configuration..."

          # Determine secret name
          $secretName = "${{ parameters.configSecretName }}"
          if ([string]::IsNullOrEmpty($secretName) -or $secretName -eq "default") {
            $secretName = "$(SECRET_NAME)"
          }

          # Determine Key Vault name
          $keyVaultName = "${{ parameters.keyVaultName }}"
          if ([string]::IsNullOrEmpty($keyVaultName) -or $keyVaultName -eq "default") {
            $keyVaultName = "$(KEYVAULT_NAME)"
          }

          Write-Host "üìã Using Key Vault: $keyVaultName"
          Write-Host "üìã Using configuration secret: $secretName"
          Write-Host "üéØ Execution mode: ${{ parameters.Mode }}"
          Write-Host "üîç What-If mode: ${{ parameters.WhatIf }}"

          # Test Azure CLI authentication
          Write-Host "üîê Testing Azure CLI authentication..."
          try {
            $account = az account show --query "{subscriptionId:id, tenantId:tenantId, user:user.name}" | ConvertFrom-Json
            Write-Host "‚úÖ Azure CLI authenticated as: $($account.user)"
            Write-Host "     Subscription: $($account.subscriptionId)"
            Write-Host "     Tenant: $($account.tenantId)"
          } catch {
            Write-Host "‚ùå Azure authentication failed: $($_.Exception.Message)"
            throw "Azure authentication test failed"
          }

          # Test Key Vault access using Azure CLI
          Write-Host "üîç Testing Key Vault access..."

          # First, check if Key Vault exists and get basic info
          Write-Host "   üìã Checking Key Vault accessibility..."
          $kvInfo = az keyvault show --name $keyVaultName --query "{name:name, location:location, enableRbacAuthorization:properties.enableRbacAuthorization, publicNetworkAccess:properties.publicNetworkAccess}" 2>$null | ConvertFrom-Json

          if ($kvInfo) {
            Write-Host "   ‚úÖ Key Vault found: $($kvInfo.name)"
            Write-Host "      Location: $($kvInfo.location)"
            Write-Host "      RBAC Authorization: $($kvInfo.enableRbacAuthorization)"
            Write-Host "      Public Network Access: $($kvInfo.publicNetworkAccess)"
          } else {
            Write-Host "   ‚ùå Cannot access Key Vault metadata"
          }

          # Check current user permissions
          Write-Host "   üîê Checking current service principal..."
          $currentUser = az account show --query "user.name" -o tsv
          Write-Host "      Current User: $currentUser"

          # Try to access the secret with detailed error output
          Write-Host "   üîë Attempting to access secret..."
          $secretValue = az keyvault secret show --vault-name $keyVaultName --name $secretName --query "value" -o tsv 2>&1

          if ($LASTEXITCODE -eq 0 -and $secretValue -and -not $secretValue.StartsWith("ERROR")) {
            Write-Host "   ‚úÖ Configuration secret found and accessible"
            Write-Host "   üìã Secret length: $($secretValue.Length) characters"
          } else {
            Write-Host "   ‚ùå Cannot access configuration secret (exit code: $LASTEXITCODE)"
            Write-Host "   üìã Key Vault: $keyVaultName"
            Write-Host "   üìã Secret Name: $secretName"
            Write-Host "   üìã Error Details: $secretValue"

            # Check if it's a permission issue vs secret not found
            Write-Host "   üîç Checking if secret exists..."
            $secretList = az keyvault secret list --vault-name $keyVaultName --query "[].name" -o tsv 2>&1
            if ($LASTEXITCODE -eq 0 -and $secretList -and -not $secretList.StartsWith("ERROR")) {
              Write-Host "   ‚úÖ Can list secrets - permission issue is with secret access"
              Write-Host "   üìã Available secrets: $($secretList -replace "`n", ", ")"
            } else {
              Write-Host "   ‚ùå Cannot list secrets - general Key Vault permission issue"
              Write-Host "   üìã List Error: $secretList"
            }

            exit 1
          }

          Write-Host "‚úÖ Validation completed successfully!"

- stage: Execution
  displayName: 'EasyPIM Policy Execution'
  dependsOn: Validation
  condition: succeeded()
  jobs:
  - job: ExecuteOrchestrator
    displayName: 'Run EasyPIM Orchestrator'
    timeoutInMinutes: 30
    steps:
    - checkout: self
      displayName: 'Checkout Repository'

    - task: PowerShell@2
      displayName: 'Install Required Modules'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "üì¶ Installing required modules from PowerShell Gallery..."
          
          # Install EasyPIM module
          Write-Host "Installing EasyPIM.Orchestrator..."
          Install-Module -Name EasyPIM.Orchestrator -Force -Scope CurrentUser -AllowClobber
          
          # Install Microsoft Graph PowerShell modules
          Write-Host "Installing Microsoft Graph Authentication module..."
          Install-Module -Name Microsoft.Graph.Authentication -Force -Scope CurrentUser -AllowClobber
          
          # Verify installations
          $easyPIM = Get-Module -ListAvailable -Name EasyPIM.Orchestrator
          $graphAuth = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
          
          if ($easyPIM) {
            Write-Host "‚úÖ EasyPIM.Orchestrator installed successfully"
            Write-Host "   Version: $($easyPIM.Version)"
          } else {
            Write-Host "‚ùå Failed to install EasyPIM.Orchestrator module"
            exit 1
          }
          
          if ($graphAuth) {
            Write-Host "‚úÖ Microsoft.Graph.Authentication installed successfully"
            Write-Host "   Version: $($graphAuth.Version)"
          } else {
            Write-Host "‚ùå Failed to install Microsoft.Graph.Authentication module"
            exit 1
          }
          
    - task: AzureCLI@2
      displayName: 'Execute EasyPIM Policy Orchestrator'
      inputs:
        azureSubscription: $(SERVICE_CONNECTION_NAME)
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          Write-Host "üöÄ Starting EasyPIM Policy Orchestrator execution..."

          # Import required modules
          Import-Module EasyPIM.Orchestrator -Force
          Import-Module Microsoft.Graph.Authentication -Force
          
          # Check Azure CLI authentication
          $account = az account show --query "{subscriptionId:id, tenantId:tenantId, user:user.name}" | ConvertFrom-Json
          Write-Host "üîê Azure CLI authenticated as: $($account.user)"
          
          # Authenticate to Microsoft Graph with enhanced method
          Write-Host "üîê Authenticating to Microsoft Graph..."
          try {
            # Method 1: Try direct connection with scopes first
            Write-Host "   üìã Attempting Connect-MgGraph with explicit scopes..."
            try {
              # Disconnect any existing session first
              try { Disconnect-MgGraph -ErrorAction SilentlyContinue } catch {}
              
              # Connect with required scope - this should work with service principal permissions
              Connect-MgGraph -Scopes "RoleManagement.ReadWrite.Directory" -NoWelcome
              
              $context = Get-MgContext
              Write-Host "‚úÖ Microsoft Graph authenticated with scopes"
              Write-Host "   Account: $($context.Account)"
              Write-Host "   Client ID: $($context.ClientId)"
              Write-Host "   Scopes: $($context.Scopes -join ', ')"
              
              if (-not ($context.Scopes -contains "RoleManagement.ReadWrite.Directory")) {
                throw "Required scope not found in context"
              }
            }
            catch {
              Write-Host "   ‚ö†Ô∏è Direct scope connection failed: $_"
              Write-Host "   üìã Trying Azure CLI token method..."
              
              # Method 2: Fallback to Azure CLI token method
              $graphToken = az account get-access-token --resource https://graph.microsoft.com --query "accessToken" -o tsv
              
              if ($graphToken) {
                # Disconnect any existing session
                try { Disconnect-MgGraph -ErrorAction SilentlyContinue } catch {}
                
                # Connect using the token
                $secureToken = ConvertTo-SecureString $graphToken -AsPlainText -Force
                Connect-MgGraph -AccessToken $secureToken -NoWelcome
                
                $context = Get-MgContext
                Write-Host "‚úÖ Microsoft Graph authenticated via token"
                Write-Host "   Account: $($context.Account)"
                Write-Host "   Client ID: $($context.ClientId)"
                Write-Host "   Scopes: $($context.Scopes -join ', ')"
                
                # Test Graph API access with multiple endpoints to find available permissions
                Write-Host "   üîç Testing Graph API access..."
                $apiTestsPassed = 0
                
                # Test 1: Basic directory access (lowest permission)
                try {
                  $orgInfo = Invoke-MgGraphRequest -Uri "https://graph.microsoft.com/v1.0/organization" -Method GET
                  Write-Host "   ‚úÖ Organization info accessible"
                  $apiTestsPassed++
                } catch {
                  Write-Host "   ‚ö†Ô∏è Organization access failed: $($_.Exception.Message)"
                }
                
                # Test 2: Service principal info (should work with app permissions)
                try {
                  $spInfo = az account show --query "{tenantId:tenantId, user:user.name}" | ConvertFrom-Json
                  $sp = Invoke-MgGraphRequest -Uri "https://graph.microsoft.com/v1.0/servicePrincipals?`$filter=appId eq '$($spInfo.user)'" -Method GET
                  Write-Host "   ‚úÖ Service principal info accessible"
                  $apiTestsPassed++
                } catch {
                  Write-Host "   ‚ö†Ô∏è Service principal access failed: $($_.Exception.Message)"
                }
                
                # Test 3: Role management (the critical one for EasyPIM)
                try {
                  $roleAssignments = Invoke-MgGraphRequest -Uri "https://graph.microsoft.com/beta/roleManagement/directory/roleAssignments?`$top=1" -Method GET
                  Write-Host "   ‚úÖ RoleManagement access confirmed - EasyPIM will work!"
                  $apiTestsPassed++
                } catch {
                  Write-Host "   ‚ùå RoleManagement access denied: $($_.Exception.Message)"
                  Write-Host "   üìã This is the core issue - service principal needs RoleManagement.ReadWrite.Directory granted (not just configured)"
                }
                
                if ($apiTestsPassed -eq 0) {
                  throw "No Graph API endpoints accessible - permission grant issue"
                } elseif ($apiTestsPassed -lt 3) {
                  Write-Host "   ‚ö†Ô∏è Partial Graph API access ($apiTestsPassed/3 tests passed)"
                  Write-Host "   üìã EasyPIM may fail due to insufficient RoleManagement permissions"
                } else {
                  Write-Host "   ‚úÖ Full Graph API access confirmed ($apiTestsPassed/3 tests passed)"
                }
              } else {
                throw "Failed to get Microsoft Graph access token"
              }
            }
          }
          catch {
            Write-Host "‚ùå Microsoft Graph authentication failed: $_"
            Write-Host "üí° Troubleshooting information:"
            Write-Host "   - Service principal has RoleManagement.ReadWrite.Directory at app registration level"
            Write-Host "   - Admin consent has been granted"
            Write-Host "   - Both direct scope and token-based authentication methods failed"
            Write-Host "   - This may indicate an EasyPIM module compatibility issue"
            exit 1
          }

          Write-Host "üìã Executing with parameters:"
          Write-Host "   KeyVaultName: $(KEYVAULT_NAME)"
          Write-Host "   SecretName: $(SECRET_NAME)"
          Write-Host "   WhatIf: ${{ parameters.WhatIf }}"
          Write-Host "   Mode: ${{ parameters.Mode }}"

          # Set environment variables for the module
          $env:AZURE_TENANT_ID = "$(AZURE_TENANT_ID)"
          $env:AZURE_SUBSCRIPTION_ID = "$(AZURE_SUBSCRIPTION_ID)"
          $env:AZURE_CLIENT_ID = "$(AZURE_CLIENT_ID)"

          # Authenticate to Azure PowerShell (required by EasyPIM.Orchestrator for Key Vault access)
          Write-Host "üîê Setting up Azure PowerShell authentication for Key Vault access..."
          try {
            # Install Azure PowerShell modules if not available
            if (-not (Get-Module -ListAvailable -Name Az.Accounts)) {
              Write-Host "   üì¶ Installing Az.Accounts module..."
              Install-Module -Name Az.Accounts -Force -Scope CurrentUser -AllowClobber
            }
            
            if (-not (Get-Module -ListAvailable -Name Az.KeyVault)) {
              Write-Host "   üì¶ Installing Az.KeyVault module..."  
              Install-Module -Name Az.KeyVault -Force -Scope CurrentUser -AllowClobber
            }
            
            Import-Module Az.Accounts -Force
            Import-Module Az.KeyVault -Force
            
            # Use the service connection context (Azure DevOps provides this automatically)
            Write-Host "   üîë Connecting to Azure PowerShell using service connection context..."
            
            # Connect using the provided service connection
            $tenantId = "$(AZURE_TENANT_ID)"
            $subscriptionId = "$(AZURE_SUBSCRIPTION_ID)"
            
            # The AzureCLI task should provide the authentication context
            # Try to leverage the existing authentication
            Connect-AzAccount -Identity -Subscription $subscriptionId -Tenant $tenantId -Force
            
            # Verify connection
            $context = Get-AzContext
            if ($context) {
              Write-Host "   ‚úÖ Azure PowerShell authenticated successfully"
              Write-Host "      Account: $($context.Account.Id)"
              Write-Host "      Subscription: $($context.Subscription.Name)"
              Write-Host "      Tenant: $($context.Tenant.Id)"
              
              # Test Key Vault access
              Write-Host "   üîç Testing Key Vault access with PowerShell..."
              try {
                $kvTest = Get-AzKeyVault -VaultName "$(KEYVAULT_NAME)" -ErrorAction Stop
                Write-Host "   ‚úÖ Key Vault accessible via Azure PowerShell"
              } catch {
                Write-Host "   ‚ö†Ô∏è Key Vault test failed: $($_.Exception.Message)"
              }
            } else {
              throw "Failed to establish Azure PowerShell context"
            }
            
          } catch {
            Write-Host "   ‚ùå Azure PowerShell authentication failed: $($_.Exception.Message)"
            Write-Host "   ÔøΩ This is expected in OIDC environments - EasyPIM may need Azure CLI fallback"
            
            # Set environment variables for Azure CLI fallback
            $env:AZURE_CLIENT_ID = "$(AZURE_CLIENT_ID)"
            $env:AZURE_TENANT_ID = "$(AZURE_TENANT_ID)"
            $env:AZURE_SUBSCRIPTION_ID = "$(AZURE_SUBSCRIPTION_ID)"
            
            Write-Host "   üìã Environment variables set for EasyPIM module Azure CLI fallback"
          }

          # Execute EasyPIM Orchestrator using the module
          try {
            # Convert string parameters to proper types
            $whatIfMode = [System.Convert]::ToBoolean("${{ parameters.WhatIf }}")
            $executionMode = "${{ parameters.Mode }}"
            
            Write-Host "üéØ Converted parameters:"
            Write-Host "   WhatIf (boolean): $whatIfMode"
            Write-Host "   Mode (string): $executionMode"
            
            # Use the EasyPIM module cmdlet
            Invoke-EasyPIMOrchestrator -KeyVaultName "$(KEYVAULT_NAME)" -SecretName "$(SECRET_NAME)" -WhatIf:$whatIfMode -Mode $executionMode -Verbose

            Write-Host "‚úÖ EasyPIM execution completed successfully!"
          }
          catch {
            Write-Host "‚ùå Error during EasyPIM execution: $_"
            Write-Host "Error details: $($_.Exception.Message)"
            exit 1
          }

  - job: GenerateReport
    displayName: 'Generate Execution Report'
    dependsOn: ExecuteOrchestrator
    condition: always()
    steps:
    - checkout: self
      displayName: 'Checkout Repository'

    - task: PowerShell@2
      displayName: 'Generate and Upload Report'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "üìä Generating execution report..."

          # Create execution summary
          $reportPath = "execution-report-$(Get-Date -Format 'yyyyMMdd-HHmmss').json"

          $report = @{
            timestamp = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
            pipeline = "$(Build.DefinitionName)"
            buildId = "$(Build.BuildId)"
            mode = "${{ parameters.Mode }}"
            whatIf = ${{ parameters.WhatIf }}
            configSecret = "$(SECRET_NAME)"
            keyVault = "$(KEYVAULT_NAME)"
            description = "${{ parameters.run_description }}"
            result = "$(Agent.JobStatus)"
          } | ConvertTo-Json -Depth 10

          $report | Out-File -FilePath $reportPath -Encoding UTF8

          Write-Host "üìã Report generated: $reportPath"
          Write-Host "üìÑ Report content:"
          Get-Content $reportPath

          Write-Host "‚úÖ Report generation completed!"

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Execution Report'
      inputs:
        pathToPublish: 'execution-report-*.json'
        artifactName: 'EasyPIM-Execution-Report'
        publishLocation: 'Container'
